**æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨ + æ¨¡æ‹Ÿ**

æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªé•¿åº¦ä¸º $5$ çš„æ–¹å‘æ•°ç»„ $dirs=[0, 1, 0, -1, 0]$ï¼Œæ•°ç»„ä¸­çš„ç›¸é‚»ä¸¤ä¸ªå…ƒç´ è¡¨ç¤ºä¸€ä¸ªæ–¹å‘ã€‚å³ $(dirs[0], dirs[1])$ è¡¨ç¤ºå‘åŒ—ï¼Œè€Œ $(dirs[1], dirs[2])$ è¡¨ç¤ºå‘ä¸œï¼Œä»¥æ­¤ç±»æ¨ã€‚

æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ $s$ æ¥å­˜å‚¨æ‰€æœ‰éšœç¢ç‰©çš„åæ ‡ï¼Œè¿™æ ·å¯ä»¥åœ¨ $O(1)$ çš„æ—¶é—´å†…åˆ¤æ–­ä¸‹ä¸€æ­¥æ˜¯å¦ä¼šé‡åˆ°éšœç¢ç‰©ã€‚

å¦å¤–ï¼Œä½¿ç”¨ä¸¤ä¸ªå˜é‡ $x$ å’Œ $y$ æ¥è¡¨ç¤ºæœºå™¨äººå½“å‰æ‰€åœ¨çš„åæ ‡ï¼Œåˆå§‹æ—¶ $x = y = 0$ã€‚å˜é‡ $k$ è¡¨ç¤ºæœºå™¨äººå½“å‰çš„æ–¹å‘ï¼Œç­”æ¡ˆå˜é‡ $ans$ è¡¨ç¤ºæœºå™¨äººè·ç¦»åŸç‚¹çš„æœ€å¤§æ¬§å¼è·ç¦»çš„å¹³æ–¹ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éå†æ•°ç»„ $commands$ ä¸­çš„æ¯ä¸ªå…ƒç´  $c$ï¼š

- å¦‚æœ $c = -2$ï¼Œè¡¨ç¤ºæœºå™¨äººå‘å·¦è½¬ $90$ åº¦ï¼Œå³ $k = (k + 3) \bmod 4$ï¼›
- å¦‚æœ $c = -1$ï¼Œè¡¨ç¤ºæœºå™¨äººå‘å³è½¬ $90$ åº¦ï¼Œå³ $k = (k + 1) \bmod 4$ï¼›
- å¦åˆ™ï¼Œè¡¨ç¤ºæœºå™¨äººå‘å‰ç§»åŠ¨ $c$ ä¸ªå•ä½é•¿åº¦ã€‚æˆ‘ä»¬å°†æœºå™¨äººå½“å‰çš„æ–¹å‘ $k$ ä¸æ–¹å‘æ•°ç»„ $dirs$ ç»“åˆï¼Œå³å¯å¾—åˆ°æœºå™¨äººåœ¨ $x$ è½´å’Œ $y$ è½´ä¸Šçš„å¢é‡ã€‚æˆ‘ä»¬å°† $c$ ä¸ªå•ä½é•¿åº¦çš„å¢é‡åˆ†åˆ«ç´¯åŠ åˆ° $x$ å’Œ $y$ ä¸Šï¼Œå¹¶åˆ¤æ–­æ¯æ¬¡ç§»åŠ¨åçš„æ–°åæ ‡ $(nx, ny)$ æ˜¯å¦åœ¨éšœç¢ç‰©çš„åæ ‡ä¸­ï¼Œå¦‚æœä¸åœ¨ï¼Œåˆ™æ›´æ–°ç­”æ¡ˆ $ans$ï¼Œå¦åˆ™åœæ­¢æ¨¡æ‹Ÿï¼Œè¿›è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤çš„æ¨¡æ‹Ÿã€‚

æœ€åè¿”å›ç­”æ¡ˆ $ans$ å³å¯ã€‚

* [sol1-Python3]

```python
class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        dirs = (0, 1, 0, -1, 0)
        s = {(x, y) for x, y in obstacles}
        ans = k = 0
        x = y = 0
        for c in commands:
            if c == -2:
                k = (k + 3) % 4
            elif c == -1:
                k = (k + 1) % 4
            else:
                for _ in range(c):
                    nx, ny = x + dirs[k], y + dirs[k + 1]
                    if (nx, ny) in s:
                        break
                    x, y = nx, ny
                    ans = max(ans, x * x + y * y)
        return ans
```

* [sol1-Java]

```java
class Solution {
    public int robotSim(int[] commands, int[][] obstacles) {
        int[] dirs = {0, 1, 0, -1, 0};
        Set<Integer> s = new HashSet<>(obstacles.length);
        for (var e : obstacles) {
            s.add(f(e[0], e[1]));
        }
        int ans = 0, k = 0;
        int x = 0, y = 0;
        for (int c : commands) {
            if (c == -2) {
                k = (k + 3) % 4;
            } else if (c == -1) {
                k = (k + 1) % 4;
            } else {
                while (c-- > 0) {
                    int nx = x + dirs[k], ny = y + dirs[k + 1];
                    if (s.contains(f(nx, ny))) {
                        break;
                    }
                    x = nx;
                    y = ny;
                    ans = Math.max(ans, x * x + y * y);
                }
            }
        }
        return ans;
    }

    private int f(int x, int y) {
        return x * 60010 + y;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        int dirs[5] = {0, 1, 0, -1, 0};
        auto f = [](int x, int y) {
            return x * 60010 + y;
        };
        unordered_set<int> s;
        for (auto& e : obstacles) {
            s.insert(f(e[0], e[1]));
        }
        int ans = 0, k = 0;
        int x = 0, y = 0;
        for (int c : commands) {
            if (c == -2) {
                k = (k + 3) % 4;
            } else if (c == -1) {
                k = (k + 1) % 4;
            } else {
                while (c--) {
                    int nx = x + dirs[k], ny = y + dirs[k + 1];
                    if (s.count(f(nx, ny))) {
                        break;
                    }
                    x = nx;
                    y = ny;
                    ans = max(ans, x * x + y * y);
                }
            }
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func robotSim(commands []int, obstacles [][]int) (ans int) {
	dirs := [5]int{0, 1, 0, -1, 0}
	type pair struct{ x, y int }
	s := map[pair]bool{}
	for _, e := range obstacles {
		s[pair{e[0], e[1]}] = true
	}
	var x, y, k int
	for _, c := range commands {
		if c == -2 {
			k = (k + 3) % 4
		} else if c == -1 {
			k = (k + 1) % 4
		} else {
			for ; c > 0 && !s[pair{x + dirs[k], y + dirs[k+1]}]; c-- {
				x += dirs[k]
				y += dirs[k+1]
				ans = max(ans, x*x+y*y)
			}
		}
	}
	return
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

* [sol1-TypeScript]

```ts
function robotSim(commands: number[], obstacles: number[][]): number {
    const dirs = [0, 1, 0, -1, 0];
    const s: Set<number> = new Set();
    const f = (x: number, y: number) => x * 60010 + y;
    for (const [x, y] of obstacles) {
        s.add(f(x, y));
    }
    let [ans, x, y, k] = [0, 0, 0, 0];
    for (let c of commands) {
        if (c === -2) {
            k = (k + 3) % 4;
        } else if (c === -1) {
            k = (k + 1) % 4;
        } else {
            while (c-- > 0) {
                const [nx, ny] = [x + dirs[k], y + dirs[k + 1]];
                if (s.has(f(nx, ny))) {
                    break;
                }
                [x, y] = [nx, ny];
                ans = Math.max(ans, x * x + y * y);
            }
        }
    }
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O(C \times n + m)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(m)$ã€‚å…¶ä¸­ $C$ è¡¨ç¤ºæ¯æ¬¡å¯ä»¥ç§»åŠ¨çš„æœ€å¤§æ­¥æ•°ï¼Œè€Œ $n$ å’Œ $m$ åˆ†åˆ«è¡¨ç¤ºæ•°ç»„ $commands$ å’Œæ•°ç»„ $obstacles$ çš„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
