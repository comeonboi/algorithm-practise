![äºŒå‰æ ‘ï¼š21.äºŒå‰æœç´¢æ ‘æœ€å°ç»å¯¹å·®.jpg](https://pic.leetcode-cn.com/1664682122-PHihMe-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A21.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.jpg)

**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[äºŒå‰æœç´¢æ ‘ä¸­ï¼Œéœ€è¦æŒæ¡å¦‚ä½•åŒæŒ‡é’ˆéå†ï¼| LeetCodeï¼š530.äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®](https://www.bilibili.com/video/BV1DD4y11779)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘åœ¨çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚

# æ€è·¯

é¢˜ç›®ä¸­è¦æ±‚åœ¨äºŒå‰æœç´¢æ ‘ä¸Šä»»æ„ä¸¤èŠ‚ç‚¹çš„å·®çš„ç»å¯¹å€¼çš„æœ€å°å€¼ã€‚

**æ³¨æ„æ˜¯äºŒå‰æœç´¢æ ‘**ï¼ŒäºŒå‰æœç´¢æ ‘å¯æ˜¯æœ‰åºçš„ã€‚

é‡åˆ°åœ¨äºŒå‰æœç´¢æ ‘ä¸Šæ±‚ä»€ä¹ˆæœ€å€¼å•Šï¼Œå·®å€¼ä¹‹ç±»çš„ï¼Œå°±æŠŠå®ƒæƒ³æˆåœ¨ä¸€ä¸ªæœ‰åºæ•°ç»„ä¸Šæ±‚æœ€å€¼ï¼Œæ±‚å·®å€¼ï¼Œè¿™æ ·å°±ç®€å•å¤šäº†ã€‚

## é€’å½’

é‚£ä¹ˆäºŒå‰æœç´¢æ ‘é‡‡ç”¨ä¸­åºéå†ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªæœ‰åºæ•°ç»„ã€‚

**åœ¨ä¸€ä¸ªæœ‰åºæ•°ç»„ä¸Šæ±‚ä¸¤ä¸ªæ•°æœ€å°å·®å€¼ï¼Œè¿™æ˜¯ä¸æ˜¯å°±æ˜¯ä¸€é“é€åˆ†é¢˜äº†ã€‚**

æœ€ç›´è§‚çš„æƒ³æ³•ï¼Œå°±æ˜¯æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢æˆæœ‰åºæ•°ç»„ï¼Œç„¶åéå†ä¸€éæ•°ç»„ï¼Œå°±ç»Ÿè®¡å‡ºæ¥æœ€å°å·®å€¼äº†ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
class Solution {
private:
vector<int> vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    vec.push_back(root->val); // å°†äºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºæœ‰åºæ•°ç»„
    traversal(root->right);
}
public:
    int getMinimumDifference(TreeNode* root) {
        vec.clear();
        traversal(root);
        if (vec.size() < 2) return 0;
        int result = INT_MAX;
        for (int i = 1; i < vec.size(); i++) { // ç»Ÿè®¡æœ‰åºæ•°ç»„çš„æœ€å°å·®å€¼
            result = min(result, vec[i] - vec[i-1]);
        }
        return result;
    }
};
```

ä»¥ä¸Šä»£ç æ˜¯æŠŠäºŒå‰æœç´¢æ ‘è½¬åŒ–ä¸ºæœ‰åºæ•°ç»„äº†ï¼Œå…¶å®åœ¨äºŒå‰æœç´ æ ‘ä¸­åºéå†çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç›´æ¥è®¡ç®—äº†ã€‚

éœ€è¦ç”¨ä¸€ä¸ªpreèŠ‚ç‚¹è®°å½•ä¸€ä¸‹curèŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚

å¦‚å›¾ï¼š

![image.png](https://pic.leetcode-cn.com/1664682107-PUUppb-image.png)

ä¸€äº›åŒå­¦ä¸çŸ¥é“åœ¨é€’å½’ä¸­å¦‚ä½•è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œå…¶å®å®ç°èµ·æ¥æ˜¯å¾ˆç®€å•çš„ï¼Œå¤§å®¶åªè¦çœ‹è¿‡ä¸€æ¬¡ï¼Œå†™è¿‡ä¸€æ¬¡ï¼Œå°±æŒæ¡äº†ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
class Solution {
private:
int result = INT_MAX;
TreeNode* pre = NULL;
void traversal(TreeNode* cur) {
    if (cur == NULL) return;
    traversal(cur->left);   // å·¦
    if (pre != NULL){       // ä¸­
        result = min(result, cur->val - pre->val);
    }
    pre = cur; // è®°å½•å‰ä¸€ä¸ª
    traversal(cur->right);  // å³
}
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
```

æ˜¯ä¸æ˜¯çœ‹ä¸Šå»ä¹Ÿå¹¶ä¸å¤æ‚ï¼

## è¿­ä»£

çœ‹è¿‡è¿™ä¸¤ç¯‡[äºŒå‰æ ‘ï¼šå¬è¯´é€’å½’èƒ½åšçš„ï¼Œæ ˆä¹Ÿèƒ½åšï¼](https://programmercarl.com/äºŒå‰æ ‘çš„è¿­ä»£éå†.html)ï¼Œ[äºŒå‰æ ‘ï¼šå‰ä¸­ååºè¿­ä»£æ–¹å¼çš„å†™æ³•å°±ä¸èƒ½ç»Ÿä¸€ä¸€ä¸‹ä¹ˆï¼Ÿ](https://programmercarl.com/äºŒå‰æ ‘çš„ç»Ÿä¸€è¿­ä»£æ³•.html)æ–‡ç« ä¹‹åï¼Œä¸éš¾å†™å‡ºä¸¤ç§ä¸­åºéå†çš„è¿­ä»£æ³•ã€‚

ä¸‹é¢æˆ‘ç»™å‡ºå…¶ä¸­çš„ä¸€ç§ä¸­åºéå†çš„è¿­ä»£æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        int result = INT_MAX;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // æŒ‡é’ˆæ¥è®¿é—®èŠ‚ç‚¹ï¼Œè®¿é—®åˆ°æœ€åº•å±‚
                st.push(cur); // å°†è®¿é—®çš„èŠ‚ç‚¹æ”¾è¿›æ ˆ
                cur = cur->left;                // å·¦
            } else {
                cur = st.top();
                st.pop();
                if (pre != NULL) {              // ä¸­
                    result = min(result, cur->val - pre->val);
                }
                pre = cur;
                cur = cur->right;               // å³
            }
        }
        return result;
    }
};
```

# æ€»ç»“

**é‡åˆ°åœ¨äºŒå‰æœç´¢æ ‘ä¸Šæ±‚ä»€ä¹ˆæœ€å€¼ï¼Œæ±‚å·®å€¼ä¹‹ç±»çš„ï¼Œéƒ½è¦æ€è€ƒä¸€ä¸‹äºŒå‰æœç´¢æ ‘å¯æ˜¯æœ‰åºçš„ï¼Œè¦åˆ©ç”¨å¥½è¿™ä¸€ç‰¹ç‚¹ã€‚**

åŒæ—¶è¦å­¦ä¼šåœ¨é€’å½’éå†çš„è¿‡ç¨‹ä¸­å¦‚ä½•è®°å½•å‰åä¸¤ä¸ªæŒ‡é’ˆï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªå°æŠ€å·§ï¼Œå­¦ä¼šäº†è¿˜æ˜¯å¾ˆå—ç”¨çš„ã€‚

åé¢æˆ‘å°†ç»§ç»­ä»‹ç»ä¸€ç³»åˆ—åˆ©ç”¨äºŒå‰æœç´¢æ ‘ç‰¹æ€§çš„é¢˜ç›®ã€‚

# å…¶ä»–è¯­è¨€ç‰ˆæœ¬

* java  []

```java  []
// é€’å½’
class Solution {
    TreeNode pre;// è®°å½•ä¸Šä¸€ä¸ªéå†çš„ç»“ç‚¹
    int result = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
       if(root==null)return 0;
       traversal(root);
       return result;
    }
    public void traversal(TreeNode root){
        if(root==null)return;
        //å·¦
        traversal(root.left);
        //ä¸­
        if(pre!=null){
            result = Math.min(result,root.val-pre.val);
        }
        pre = root;
        //å³
        traversal(root.right);
    }
}

// è¿­ä»£æ³•-ä¸­åºéå†
class Solution {
    TreeNode pre;
    Stack<TreeNode> stack;
    public int getMinimumDifference(TreeNode root) {
        if (root == null) return 0;
        stack = new Stack<>();
        TreeNode cur = root;
        int result = Integer.MAX_VALUE;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur); // å°†è®¿é—®çš„èŠ‚ç‚¹æ”¾è¿›æ ˆ
                cur = cur.left; // å·¦
            }else {
                cur = stack.pop(); 
                if (pre != null) { // ä¸­
                    result = Math.min(result, cur.val - pre.val);
                }
                pre = cur;
                cur = cur.right; // å³
            }
        }
        return result;
    }
}
```

* []

```python
# é€’å½’
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        res = []   
        r = float("inf")
        def buildaList(root):  //æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢æˆæœ‰åºæ•°ç»„
            if not root: return None
            if root.left: buildaList(root.left)  //å·¦
            res.append(root.val)  //ä¸­
            if root.right: buildaList(root.right)  //å³
            return res
            
        buildaList(root)
        for i in range(len(res)-1):  // ç»Ÿè®¡æœ‰åºæ•°ç»„çš„æœ€å°å·®å€¼
            r = min(abs(res[i]-res[i+1]),r)
        return r
 
# è¿­ä»£æ³•-ä¸­åºéå†
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        stack = []
        cur = root
        pre = None
        result = float('inf')
        while cur or stack:
            if cur: # æŒ‡é’ˆæ¥è®¿é—®èŠ‚ç‚¹ï¼Œè®¿é—®åˆ°æœ€åº•å±‚
                stack.append(cur)
                cur = cur.left
            else: # é€ä¸€å¤„ç†èŠ‚ç‚¹
                cur = stack.pop()
                if pre: # å½“å‰èŠ‚ç‚¹å’Œå‰èŠ‚ç‚¹çš„å€¼çš„å·®å€¼
                    result = min(result, abs(cur.val - pre.val))
                pre = cur
                cur = cur.right
        return result
        
```

* []

```go
// ä¸­åºéå†ï¼Œç„¶åè®¡ç®—æœ€å°å·®å€¼
func getMinimumDifference(root *TreeNode) int {
    var res []int
    findMIn(root,&res)
    min:=1000000//ä¸€ä¸ªæ¯”è¾ƒå¤§çš„å€¼
    for i:=1;i<len(res);i++{
        tempValue:=res[i]-res[i-1]
        if tempValue<min{
            min=tempValue
        }
    }
    return min
}
//ä¸­åºéå†
func findMIn(root *TreeNode,res *[]int){
    if root==nil{return}
    findMIn(root.Left,res)
    *res=append(*res,root.Val)
    findMIn(root.Right,res)
}

// ä¸­åºéå†çš„åŒæ—¶è®¡ç®—æœ€å°å€¼
func getMinimumDifference(root *TreeNode) int {
    // ä¿ç•™å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ
    var prev *TreeNode
    // å®šä¹‰ä¸€ä¸ªæ¯”è¾ƒå¤§çš„å€¼
    min := math.MaxInt64
    var travel func(node *TreeNode)
    travel = func(node *TreeNode) {
        if node == nil {
            return 
        }
        travel(node.Left)
        if prev != nil && node.Val - prev.Val < min {
            min = node.Val - prev.Val
        }
        prev = node
        travel(node.Right)
    }
    travel(root)
    return min
}
```

* []

```javascript

/** é€’å½’ å…ˆè½¬æ¢ä¸ºæœ‰åºæ•°ç»„
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var getMinimumDifference = function (root) {
    let arr = [];
    const buildArr = (root) => {
        if (root) {
            buildArr(root.left);
            arr.push(root.val);
            buildArr(root.right);
        }
    }
    buildArr(root);
    let diff = arr[arr.length - 1];
    for (let i = 1; i < arr.length; ++i) {
        if (diff > arr[i] - arr[i - 1])
            diff = arr[i] - arr[i - 1];
    }
    return diff;
};

// é€’å½’ åœ¨é€’å½’çš„è¿‡ç¨‹ä¸­æ›´æ–°æœ€å°å€¼
var getMinimumDifference = function(root) {
    let res = Infinity
    let preNode = null
    // ä¸­åºéå†
    const inorder = (node) => {
        if(!node) return
        inorder(node.left)
        // æ›´æ–°res
        if(preNode) res = Math.min(res, node.val - preNode.val)
        // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹         
        preNode = node
        inorder(node.right)
    }
    inorder(root)
    return res
}

// è¿­ä»£  ä¸­åºéå†
var getMinimumDifference = function(root) {
    let stack = []
    let cur = root
    let res = Infinity
    let pre = null
    while(cur || stack.length) {
        if(cur) {
            stack.push(cur)
            cur = cur.left
        } else {
            cur = stack.pop()
            if(pre) res = Math.min(res, cur.val - pre.val)
            pre = cur
            cur = cur.right
        }
    }
    return res
}
```

* []

```typescript
// > è¾…åŠ©æ•°ç»„è§£å†³
function getMinimumDifference(root: TreeNode | null): number {
    let helperArr: number[] = [];
    function recur(root: TreeNode | null): void {
        if (root === null) return;
        recur(root.left);
        helperArr.push(root.val);
        recur(root.right);
    }
    recur(root);
    let resMin: number = Infinity;
    for (let i = 0, length = helperArr.length; i < length - 1; i++) {
        resMin = Math.min(resMin, helperArr[i + 1] - helperArr[i]);
    }
    return resMin;
};

// > é€’å½’ä¸­è§£å†³
function getMinimumDifference(root: TreeNode | null): number {
    let preNode: TreeNode | null= null;
    let resMin: number = Infinity;
    function recur(root: TreeNode | null): void {
        if (root === null) return;
        recur(root.left);
        if (preNode !== null) {
            resMin = Math.min(resMin, root.val - preNode.val);
        }
        preNode = root;
        recur(root.right);
    }
    recur(root);
    return resMin;
};

// > è¿­ä»£æ³•-ä¸­åºéå†
function getMinimumDifference(root: TreeNode | null): number {
    const helperStack: TreeNode[] = [];
    let curNode: TreeNode | null = root;
    let resMin: number = Infinity;
    let preNode: TreeNode | null = null;
    while (curNode !== null || helperStack.length > 0) {
        if (curNode !== null) {
            helperStack.push(curNode);
            curNode = curNode.left;
        } else {
            curNode = helperStack.pop()!;
            if (preNode !== null) {
                resMin = Math.min(resMin, curNode.val - preNode.val);
            }
            preNode = curNode;
            curNode = curNode.right;
        }
    }
    return resMin;
};

// æ„å»ºäºŒå‰æ ‘çš„æœ‰åºæ•°ç»„:
object Solution {
  import scala.collection.mutable
  def getMinimumDifference(root: TreeNode): Int = {
    val arr = mutable.ArrayBuffer[Int]()
    def traversal(node: TreeNode): Unit = {
      if (node == null) return
      traversal(node.left)
      arr.append(node.value)
      traversal(node.right)
    }
    traversal(root)
    // åœ¨æœ‰åºæ•°ç»„ä¸Šæ±‚æœ€å°å·®å€¼
    var result = Int.MaxValue
    for (i <- 1 until arr.size) {
      result = math.min(result, arr(i) - arr(i - 1))
    }
    result // è¿”å›æœ€å°å·®å€¼
  }
}
```

* []

```scala
// é€’å½’è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹:
object Solution {
  def getMinimumDifference(root: TreeNode): Int = {
    var result = Int.MaxValue // åˆå§‹åŒ–ä¸ºæœ€å¤§å€¼
    var pre: TreeNode = null // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹

    def traversal(cur: TreeNode): Unit = {
      if (cur == null) return
      traversal(cur.left)
      if (pre != null) {
        // å¯¹æ¯”resultä¸èŠ‚ç‚¹ä¹‹é—´çš„å·®å€¼
        result = math.min(result, cur.value - pre.value)
      }
      pre = cur
      traversal(cur.right)
    }

    traversal(root)
    result // returnå…³é”®å­—å¯ä»¥çœç•¥
  }
}

// è¿­ä»£è§£å†³:
object Solution {
  import scala.collection.mutable
  def getMinimumDifference(root: TreeNode): Int = {
    var result = Int.MaxValue // åˆå§‹åŒ–ä¸ºæœ€å¤§å€¼
    var pre: TreeNode = null // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
    var cur = root
    var stack = mutable.Stack[TreeNode]()
    while (cur != null || !stack.isEmpty) {
      if (cur != null) {
        stack.push(cur)
        cur = cur.left
      } else {
        cur = stack.pop()
        if (pre != null) {
          result = math.min(result, cur.value - pre.value)
        }
        pre = cur
        cur = cur.right
      }
    }
    result // returnå…³é”®å­—å¯ä»¥çœç•¥
  }
}
```

# äºŒå‰æ ‘åŠ›æ‰£é¢˜ç›®æ€»ç»“

æŒ‰ç…§å¦‚ä¸‹é¡ºåºåˆ·åŠ›æ‰£ä¸Šçš„é¢˜ç›®ï¼Œç›¸ä¿¡ä¼šå¸®ä½ åœ¨å­¦ä¹ äºŒå‰æ ‘çš„è·¯ä¸Šå°‘èµ°å¾ˆå¤šå¼¯è·¯ã€‚

![image.png](https://pic.leetcode-cn.com/1625557068-rTzCSW-image.png)

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œå¦‚æœä½ è¿˜åœ¨æ²¡æœ‰ç« æ³•çš„åˆ·é¢˜ï¼Œ**å»ºè®®æŒ‰ç…§[ä»£ç éšæƒ³å½•åˆ·é¢˜è·¯çº¿](https://programmercarl.com/)æ¥åˆ·**ï¼Œå¹¶æä¾›[PDFä¸‹è½½](https://programmercarl.com/other/algo_pdf.html)ï¼Œåˆ·é¢˜è·¯çº¿åŒæ—¶ä¹Ÿå¼€æºåœ¨[Github](https://github.com/youngyangyang04/leetcode-master)ä¸Šï¼Œä½ ä¼šå‘ç°è¯¦è§å¾ˆæ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**
