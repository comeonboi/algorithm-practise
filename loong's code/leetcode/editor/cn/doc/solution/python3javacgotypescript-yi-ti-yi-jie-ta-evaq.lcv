**æ–¹æ³•ä¸€ï¼šè´ªå¿ƒ + æ’åº + å“ˆå¸Œè¡¨**

æ ¹æ®é¢˜ç›®æè¿°ï¼Œæˆ‘ä»¬éœ€è¦ä» $n$ ä¸ªå…ƒç´ çš„é›†åˆä¸­é€‰å‡ºä¸€ä¸ªå­é›†ï¼Œå­é›†å…ƒç´ ä¸ªæ•°ä¸è¶…è¿‡ $numWanted$ï¼Œä¸”å­é›†ä¸­æœ€å¤šæœ‰ç›¸åŒæ ‡ç­¾çš„ $useLimit$ é¡¹ï¼Œä½¿å¾—å­é›†çš„å€¼ä¹‹å’Œæœ€å¤§ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥è´ªå¿ƒåœ°é€‰æ‹©é›†åˆä¸­å€¼è¾ƒå¤§çš„å…ƒç´ ï¼ŒåŒæ—¶è®°å½•æ¯ä¸ªæ ‡ç­¾å‡ºç°çš„æ¬¡æ•°ï¼Œå½“æŸä¸ªæ ‡ç­¾å‡ºç°çš„æ¬¡æ•°è¾¾åˆ° $useLimit$ æ—¶ï¼Œæˆ‘ä»¬å°±ä¸èƒ½å†é€‰æ‹©è¯¥æ ‡ç­¾å¯¹åº”çš„å…ƒç´ äº†ã€‚

å…·ä½“åœ°ï¼Œæˆ‘ä»¬å…ˆå°†é›†åˆä¸­çš„å…ƒç´ æŒ‰ç…§å€¼ä»å¤§åˆ°å°è¿›è¡Œæ’åºï¼Œç„¶åä»å‰å¾€åéå†æ’åºåçš„å…ƒç´ ã€‚åœ¨éå†çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ $cnt$ è®°å½•æ¯ä¸ªæ ‡ç­¾å‡ºç°çš„æ¬¡æ•°ï¼Œå¦‚æœæŸä¸ªæ ‡ç­¾å‡ºç°çš„æ¬¡æ•°è¾¾åˆ°äº† $useLimit$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è·³è¿‡è¯¥å…ƒç´ ï¼Œå¦åˆ™æˆ‘ä»¬å°±å°†è¯¥å…ƒç´ çš„å€¼åŠ åˆ°æœ€ç»ˆçš„ç­”æ¡ˆä¸­ï¼Œå¹¶å°†è¯¥æ ‡ç­¾å‡ºç°çš„æ¬¡æ•°åŠ  $1$ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªå˜é‡ $num$ è®°å½•å½“å‰å­é›†ä¸­çš„å…ƒç´ ä¸ªæ•°ï¼Œå½“ $num$ è¾¾åˆ° $numWanted$ æ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç»“æŸéå†äº†ã€‚

éå†ç»“æŸåï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†æœ€å¤§çš„åˆ†æ•°ã€‚

* [sol1-Python3]

```python
class Solution:
    def largestValsFromLabels(
        self, values: List[int], labels: List[int], numWanted: int, useLimit: int
    ) -> int:
        ans = num = 0
        cnt = Counter()
        for v, l in sorted(zip(values, labels), reverse=True):
            if cnt[l] < useLimit:
                cnt[l] += 1
                num += 1
                ans += v
                if num == numWanted:
                    break
        return ans
```

* [sol1-Java]

```java
class Solution {
    public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {
        int n = values.length;
        int[][] pairs = new int[n][2];
        for (int i = 0; i < n; ++i) {
            pairs[i] = new int[]{values[i], labels[i]};
        }
        Arrays.sort(pairs, (a, b) -> b[0] - a[0]);
        Map<Integer, Integer> cnt = new HashMap<>();
        int ans = 0, num = 0;
        for (int i = 0; i < n && num < numWanted; ++i) {
            int v = pairs[i][0], l = pairs[i][1];
            if (cnt.getOrDefault(l, 0) < useLimit) {
                cnt.merge(l, 1, Integer::sum);
                num += 1;
                ans += v;
            }
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int largestValsFromLabels(vector<int>& values, vector<int>& labels, int numWanted, int useLimit) {
        int n = values.size();
        vector<pair<int, int>> pairs(n);
        for (int i = 0; i < n; ++i) {
            pairs[i] = {-values[i], labels[i]};
        }
        sort(pairs.begin(), pairs.end());
        unordered_map<int, int> cnt;
        int ans = 0, num = 0;
        for (int i = 0; i < n && num < numWanted; ++i) {
            int v = -pairs[i].first, l = pairs[i].second;
            if (cnt[l] < useLimit) {
                ++cnt[l];
                ++num;
                ans += v;
            }
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func largestValsFromLabels(values []int, labels []int, numWanted int, useLimit int) (ans int) {
	n := len(values)
	pairs := make([][2]int, n)
	for i := 0; i < n; i++ {
		pairs[i] = [2]int{values[i], labels[i]}
	}
	sort.Slice(pairs, func(i, j int) bool { return pairs[i][0] > pairs[j][0] })
	cnt := map[int]int{}
	for i, num := 0, 0; i < n && num < numWanted; i++ {
		v, l := pairs[i][0], pairs[i][1]
		if cnt[l] < useLimit {
			cnt[l]++
			num++
			ans += v
		}
	}
	return
}
```

* [sol1-TypeScript]

```ts
function largestValsFromLabels(
    values: number[],
    labels: number[],
    numWanted: number,
    useLimit: number,
): number {
    const n = values.length;
    const pairs = new Array(n);
    for (let i = 0; i < n; ++i) {
        pairs[i] = [values[i], labels[i]];
    }
    pairs.sort((a, b) => b[0] - a[0]);
    const cnt: Map<number, number> = new Map();
    let ans = 0;
    for (let i = 0, num = 0; i < n && num < numWanted; ++i) {
        const [v, l] = pairs[i];
        if ((cnt.get(l) || 0) < useLimit) {
            cnt.set(l, (cnt.get(l) || 0) + 1);
            ++num;
            ans += v;
        }
    }
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O(n \times \log n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚å…¶ä¸­ $n$ æ˜¯é›†åˆä¸­çš„å…ƒç´ ä¸ªæ•°ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
